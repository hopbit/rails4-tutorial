#! /usr/bin/env ruby
# -*- coding: utf-8 -*-

# Autor: Maciej Małecki
#
# Zależności
#   gem install github_api bitbucket_rest_api ansi
#
# Format pliku CSV z danymi:
#
#  Imię,Nazwisko,login,repo,github|bitbucket,kiedy
#  Nieznany,Nieznany,pypy,pypay,bitbucket,pon12
#  Jakis,User,pypy,pypy,bitbucket,wto12

require 'ansi/code'          # http://rubydoc.info/gems/ansi/frames
require 'bitbucket_rest_api' # http://rubydoc.info/gems/bitbucket_rest_api/frames
require 'github_api'         # http://rubydoc.info/gems/github_api/frames
require 'csv'
require 'time'
require 'optparse'
require 'ostruct'

include ANSI::Code

# na podstawie http://github.com/wbzyl/nosql-tutorial/blob/master/pp/db/mongodb/gutenberg2mongo.rb

class ParseArgs
  def self.parse(args)
    options = OpenStruct.new
    options.quiet_mode = false
    options.group = false
    options.csv_file = false
    options.message = false
    options.user_regex = false
    options.commits = 1

    opts = OptionParser.new do |opts|
      opts.banner = "Użycie: #{$0} [OPCJE]"

      opts.on("-f", "--file DATE.CSV", "Plik csv z danymi") do |file|
        options.csv_file = file
      end

      opts.on("-q", "--quiet") do
        options.quiet_mode = true
      end

      opts.on("-g", "--group GRUPA", "grupa (pon12,wto10,wto12)") do |name|
        options.group = name
      end

      opts.on("-m", "--message", "wyświetl wiadomość wysłaną z commitem") do
        options.message = true
      end

      opts.on("-u", "--user REGEX", "wyrażenie regularne do filtrowania loginu") do |regex|
        options.user_regex = regex
      end

      opts.on("-c", "--commits NUMBER", "ilość comitów do wyświetlenia. Domyślnie 1, Wszystkie 0") do |number|
        options.commits = number
      end

      opts.separator "Pozostałe opcje:"

      opts.on_tail("-h", "--help", "wypisz pomoc") do
        puts opts
        exit
      end

    end

    opts.parse!(args)
    options
  end
end

options = ParseArgs.parse(ARGV)

def parse_message(procrastinate, login, repo, author, message, options, lab)
  line = "#{procrastinate} #{yellow(login + '/' + repo)} (#{author})"
  if options.message
    line += " {" + cyan(message) + "}"
  end
  if options.group && options.group == lab
    puts line
  elsif !options.group
    puts line += " " + magenta(lab)
  end
end

def commits_to_show(array_size, options)
  if options.commits.to_i == 0
    commits_to_show = array_size-1
  else
    commits_to_show = options.commits.to_i
  end
end

def repo_not_found(login, repo, name, surname)
  puts "Nie znaleziono konta #{yellow(login)} lub repozytorium #{yellow(repo)} dla #{red(name)} #{red(surname)}"
end

if not options.csv_file
  puts "Pomoc: #{$0} --help"
  exit
end

trap("SIGINT") { throw :ctrl_c }

catch :ctrl_c do
  begin
    data = open(options.csv_file).readlines
    csv_data = CSV.parse(data.join)

    bitbucket = BitBucket.new
    github = Github.new

    csv_data.each do |repo|
      if options.user_regex && !(repo[2].downcase =~ /#{options.user_regex}/)
        next
      end

      lab = repo[5]
      if repo[4]=="bitbucket"
        begin
          _info_array = bitbucket.repos.changesets.all repo[2], repo[3]

          for i in 1..commits_to_show(_info_array.changesets.size, options)
            last_commit = _info_array.changesets[_info_array.changesets.size-i]

            date = last_commit[:timestamp]
            procrastinate = date < Date.today.prev_day(8).to_s ? red(date) : green(date)
            parse_message(procrastinate, repo[2], repo[3], last_commit[:raw_author], last_commit[:message], options, lab)
          end
        rescue
          if options.quiet_mode
            next
          else
            repo_not_found(repo[2], repo[3], repo[0], repo[1])
          end
        end
      elsif repo[4]=="github"
        begin
          _info_array = github.repos.commits.list(repo[2], repo[3], page: 1, per_page: 0)

          for i in 0..(commits_to_show(_info_array.size, options)-1)
            last_commit = _info_array[i]
            author = last_commit.commit.author
            date = DateTime.parse(author[:date]).strftime("%F %T")#.iso8601(author[:date])
            procrastinate = Date.iso8601(author[:date]).to_date < Date.today.prev_day(8) ? red(date) : green(date)
            parse_message(procrastinate, repo[2], repo[3], author.name + " <#{author.email}>", last_commit.commit[:message], options, lab)
          end
        rescue
          if options.quiet_mode
            next
          else
            repo_not_found(repo[2], repo[3], repo[0], repo[1])
          end
        end
      else
        line =  "Zdefiniuj rodzaj repozytorium!"
      end
    end
  rescue
    #exit
  end
end
